"""
EffectiveVelocityCalculator: Perry Husband's Effective Velocity Theory

Perry Husband's Effective Velocity (EV) ì´ë¡ :
- íƒ€ìì˜ ëˆˆì—ì„œ ê°€ê¹Œìš´ ê³µ(ëª¸ìª½)ì€ ì‹¤ì œë³´ë‹¤ ë¹ ë¥´ê²Œ ë³´ì„
- íƒ€ìì˜ ëˆˆì—ì„œ ë¨¼ ê³µ(ë°”ê¹¥ìª½)ì€ ì‹¤ì œë³´ë‹¤ ëŠë¦¬ê²Œ ë³´ì„
- ë†’ì€ ê³µì€ ëˆˆì— ê°€ê¹Œì›Œ ë¹ ë¥´ê²Œ ë³´ì´ê³ , ë‚®ì€ ê³µì€ ëŠë¦¬ê²Œ ë³´ì„

Reference: Perry Husband, "The Effective Velocity Concept"
"""

from typing import Tuple, Optional
import numpy as np


class EffectiveVelocityCalculator:
    """
    Perry Husbandì˜ Effective Velocity ì´ë¡  êµ¬í˜„

    íƒ€ìì˜ ì²´ê° ì†ë„ë¥¼ ê³„ì‚°í•˜ì—¬ íˆ¬êµ¬ ì‹œí€€ì‹± ìµœì í™”

    Core Principle:
        - ê¸°ì¤€ì : í™ˆí”Œë ˆì´íŠ¸ ì •ì¤‘ì•™, ë²¨íŠ¸ ë†’ì´ (EV = ì‹¤ì œ êµ¬ì†)
        - ëª¸ìª½ ê³µ: ì²´ê° ì†ë„ ì¦ê°€
        - ë°”ê¹¥ìª½ ê³µ: ì²´ê° ì†ë„ ê°ì†Œ
        - ë†’ì€ ê³µ: ì²´ê° ì†ë„ ì¦ê°€
        - ë‚®ì€ ê³µ: ì²´ê° ì†ë„ ê°ì†Œ

    Constants:
        LATERAL_ADJUSTMENT: ì¢Œìš° 1ì¸ì¹˜ë‹¹ ì²´ê° ì†ë„ ë³€í™” (mph/inch)
        VERTICAL_ADJUSTMENT: ìƒí•˜ 1ì¸ì¹˜ë‹¹ ì²´ê° ì†ë„ ë³€í™” (mph/inch)
        BELT_HEIGHT: ë²¨íŠ¸ ë†’ì´ ê¸°ì¤€ì  (ft)
        PLATE_CENTER: í™ˆí”Œë ˆì´íŠ¸ ì¤‘ì•™ (ft)
    """

    # Perry Husbandì˜ ì—°êµ¬ ê¸°ë°˜ ìƒìˆ˜
    # ì¢Œìš° 6ì¸ì¹˜ë‹¹ 2.5mph -> 1ì¸ì¹˜ë‹¹ ì•½ 0.417mph
    LATERAL_ADJUSTMENT = 0.417  # mph per inch

    # ìƒí•˜ 6ì¸ì¹˜ë‹¹ 1.0mph -> 1ì¸ì¹˜ë‹¹ ì•½ 0.167mph

    # ê¸°ì¤€ì 
    BELT_HEIGHT = 2.5  # ft (ì•½ 30 inches, MLB average)
    PLATE_CENTER = 0.0  # ft (í™ˆí”Œë ˆì´íŠ¸ ì¤‘ì•™)

    # í™ˆí”Œë ˆì´íŠ¸ ë„ˆë¹„ (17 inches = 1.417 ft)
    PLATE_WIDTH = 1.417  # ft

    def __init__(
        self,
        lateral_factor: float = 1.0,
        vertical_factor: float = 1.0
    ):
        """
        EffectiveVelocityCalculator ì´ˆê¸°í™”

        Args:
            lateral_factor: ì¢Œìš° ë³´ì • ê³„ìˆ˜ (1.0 = í‘œì¤€)
            vertical_factor: ìƒí•˜ ë³´ì • ê³„ìˆ˜ (1.0 = í‘œì¤€)
        """
        self.lateral_factor = lateral_factor
        self.vertical_factor = vertical_factor
        self.last_ev: Optional[float] = None

        print(f"âœ… EffectiveVelocityCalculator ì´ˆê¸°í™”")
        print(f"   Lateral Factor: {lateral_factor:.2f}")
        print(f"   Vertical Factor: {vertical_factor:.2f}")

    def calculate_ev(
        self,
        release_speed: float,
        plate_x: float,
        plate_z: float,
        batter_stand: str
    ) -> float:
        """
        Effective Velocity ê³„ì‚°

        Args:
            release_speed: ì‹¤ì œ êµ¬ì† (mph)
            plate_x: í™ˆí”Œë ˆì´íŠ¸ ì¢Œìš° ìœ„ì¹˜ (ft, í¬ìˆ˜ ì‹œì )
                     ìŒìˆ˜(-): ì¢Œíƒ€ìì„ ë°©í–¥
                     ì–‘ìˆ˜(+): ìš°íƒ€ìì„ ë°©í–¥
            plate_z: í™ˆí”Œë ˆì´íŠ¸ ë†’ì´ (ft)
            batter_stand: íƒ€ì íƒ€ì„ ('L' = ì¢Œíƒ€ì, 'R' = ìš°íƒ€ì)

        Returns:
            effective_velocity: ì²´ê° ì†ë„ (mph)

        Formula:
            EV = Vâ‚€ + Î”V_lateral + Î”V_vertical

            where:
            - Î”V_lateral: ì¢Œìš° ë³´ì • (ëª¸ìª½ = ê°€ì‚°, ë°”ê¹¥ìª½ = ê°ì‚°)
            - Î”V_vertical: ìƒí•˜ ë³´ì • (ë†’ìŒ = ê°€ì‚°, ë‚®ìŒ = ê°ì‚°)
        """
        # ì…ë ¥ ê²€ì¦
        if batter_stand not in ['L', 'R']:
            raise ValueError(f"batter_stand must be 'L' or 'R', got: {batter_stand}")

        # 1. Lateral Adjustment (ì¢Œìš° ë³´ì •)
        lateral_ev_delta = self._calculate_lateral_adjustment(
            plate_x, batter_stand
        )

        # 2. Vertical Adjustment (ìƒí•˜ ë³´ì •)
        vertical_ev_delta = self._calculate_vertical_adjustment(plate_z)

        # 3. Total Effective Velocity
        effective_velocity = (
            release_speed +
            lateral_ev_delta * self.lateral_factor +
            vertical_ev_delta * self.vertical_factor
        )


        Args:
            plate_x: í™ˆí”Œë ˆì´íŠ¸ ì¢Œìš° ìœ„ì¹˜ (ft)
            batter_stand: íƒ€ì íƒ€ì„ ('L' or 'R')

        Returns:
            delta_ev: ì²´ê° ì†ë„ ë³€í™”ëŸ‰ (mph)

        Logic:
            - ì¢Œíƒ€ì (L): plate_x < 0 = ëª¸ìª½ (Inner) = ë¹ ë¥´ê²Œ ë³´ì„ (+)
                          plate_x > 0 = ë°”ê¹¥ìª½ (Outer) = ëŠë¦¬ê²Œ ë³´ì„ (-)
            - ìš°íƒ€ì (R): plate_x > 0 = ëª¸ìª½ (Inner) = ë¹ ë¥´ê²Œ ë³´ì„ (+)
                          plate_x < 0 = ë°”ê¹¥ìª½ (Outer) = ëŠë¦¬ê²Œ ë³´ì„ (-)
        """
        # í”Œë ˆì´íŠ¸ ì¤‘ì•™ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ (inches)
        distance_from_center_ft = plate_x - self.PLATE_CENTER
        distance_from_center_inch = distance_from_center_ft * 12  # ft -> inches

        # íƒ€ìë³„ ëª¸ìª½/ë°”ê¹¥ìª½ íŒë³„
        if batter_stand == 'L':
            # ì¢Œíƒ€ì: ìŒìˆ˜ = ëª¸ìª½, ì–‘ìˆ˜ = ë°”ê¹¥ìª½
            # ëª¸ìª½(-) = ê°€ì‚°(+), ë°”ê¹¥ìª½(+) = ê°ì‚°(-)
            ev_delta = -distance_from_center_inch * self.LATERAL_ADJUSTMENT
        else:  # 'R'
            # ìš°íƒ€ì: ì–‘ìˆ˜ = ëª¸ìª½, ìŒìˆ˜ = ë°”ê¹¥ìª½
            # ëª¸ìª½(+) = ê°€ì‚°(+), ë°”ê¹¥ìª½(-) = ê°ì‚°(-)
            ev_delta = distance_from_center_inch * self.LATERAL_ADJUSTMENT

        return ev_delta

    def _calculate_vertical_adjustment(
        self,
        plate_z: float
    ) -> float:
        """
        ìƒí•˜ ë†’ì´ ê¸°ë°˜ ì²´ê° ì†ë„ ë³´ì •

        Args:
            plate_z: í™ˆí”Œë ˆì´íŠ¸ ë†’ì´ (ft)

        Returns:
            delta_ev: ì²´ê° ì†ë„ ë³€í™”ëŸ‰ (mph)

        Logic:
            - ë²¨íŠ¸ ë†’ì´ (2.5 ft) ê¸°ì¤€
            - ë†’ì€ ê³µ (plate_z > 2.5 ft) = ë¹ ë¥´ê²Œ ë³´ì„ (+)
            - ë‚®ì€ ê³µ (plate_z < 2.5 ft) = ëŠë¦¬ê²Œ ë³´ì„ (-)
        """
        # ë²¨íŠ¸ ë†’ì´ë¡œë¶€í„°ì˜ ì°¨ì´ (inches)
        height_diff_ft = plate_z - self.BELT_HEIGHT
        height_diff_inch = height_diff_ft * 12  # ft -> inches

        # ë†’ì„ìˆ˜ë¡ ë¹ ë¥´ê²Œ ë³´ì„
        ev_delta = height_diff_inch * self.VERTICAL_ADJUSTMENT

        return ev_delta

    def get_velocity_delta(
        self,
        current_ev: Optional[float] = None,
        release_speed: Optional[float] = None,
        plate_x: Optional[float] = None,
        plate_z: Optional[float] = None,
        batter_stand: Optional[str] = None
    ) -> Optional[float]:
        """
        ì´ì „ íˆ¬êµ¬ì™€ í˜„ì¬ íˆ¬êµ¬ì˜ EV ì°¨ì´ ê³„ì‚°

        Args:
            current_ev: í˜„ì¬ íˆ¬êµ¬ì˜ Effective Velocity (mph)
                        Noneì¸ ê²½ìš° ë‚˜ë¨¸ì§€ íŒŒë¼ë¯¸í„°ë¡œ ê³„ì‚°
            release_speed: ì‹¤ì œ êµ¬ì† (mph, current_ev=Noneì¼ ë•Œ í•„ìˆ˜)
            plate_x: ì¢Œìš° ìœ„ì¹˜ (ft, current_ev=Noneì¼ ë•Œ í•„ìˆ˜)
            plate_z: ë†’ì´ (ft, current_ev=Noneì¼ ë•Œ í•„ìˆ˜)
            batter_stand: íƒ€ì íƒ€ì„ ('L' or 'R', current_ev=Noneì¼ ë•Œ í•„ìˆ˜)

        Returns:
            velocity_delta: |EV_current - EV_previous| (mph)
                            ì²« íˆ¬êµ¬ì¸ ê²½ìš° None

        Usage:
            # Method 1: EVë¥¼ ì§ì ‘ ì „ë‹¬
            ev1 = calculator.calculate_ev(95.0, -0.5, 2.8, 'L')
            delta = calculator.get_velocity_delta(current_ev=ev1)

            # Method 2: íŒŒë¼ë¯¸í„°ë¡œ ê³„ì‚°
            calculator.calculate_ev(95.0, -0.5, 2.8, 'L')
            delta = calculator.get_velocity_delta(
                release_speed=87.0,
                plate_x=0.5,
                plate_z=2.0,
                batter_stand='L'
            )
        """
        # current_evê°€ ì—†ìœ¼ë©´ ê³„ì‚°
        if current_ev is None:
            if None in [release_speed, plate_x, plate_z, batter_stand]:
                raise ValueError(
                    "Either current_ev or all of "
                    "(release_speed, plate_x, plate_z, batter_stand) must be provided"
                )
            current_ev = self.calculate_ev(release_speed, plate_x, plate_z, batter_stand)

        # ì²« íˆ¬êµ¬ì¸ ê²½ìš°
        if self.last_ev is None:
            self.last_ev = current_ev
            return None

        # Delta ê³„ì‚°
        velocity_delta = abs(current_ev - self.last_ev)

        # í˜„ì¬ EVë¥¼ last_evë¡œ ì—…ë°ì´íŠ¸
        self.last_ev = current_ev

    def get_location_descriptor(
        self,
        plate_x: float,
        plate_z: float,
        batter_stand: str
    ) -> Tuple[str, str]:
        """
        íˆ¬êµ¬ ìœ„ì¹˜ ì„¤ëª… (ë””ë²„ê¹…/ì‹œê°í™”ìš©)

        Args:
            plate_x: í™ˆí”Œë ˆì´íŠ¸ ì¢Œìš° ìœ„ì¹˜ (ft)
            plate_z: í™ˆí”Œë ˆì´íŠ¸ ë†’ì´ (ft)
            batter_stand: íƒ€ì íƒ€ì„ ('L' or 'R')

        Returns:
            tuple: (lateral_desc, vertical_desc)
                - lateral_desc: 'Inner', 'Middle', 'Outer'
                - vertical_desc: 'High', 'Middle', 'Low'
        """
        # Lateral (ì¢Œìš°)
        if batter_stand == 'L':
            if plate_x < -0.2:
                lateral_desc = 'Inner'
            elif plate_x > 0.2:
                lateral_desc = 'Outer'
            else:
                lateral_desc = 'Middle'
        else:  # 'R'
            if plate_x > 0.2:
                lateral_desc = 'Inner'
            elif plate_x < -0.2:
                lateral_desc = 'Outer'
            else:
                lateral_desc = 'Middle'

        # Vertical (ìƒí•˜)
        if plate_z > 2.8:
            vertical_desc = 'High'
        elif plate_z < 2.2:
            vertical_desc = 'Low'
        else:
            vertical_desc = 'Middle'

        return lateral_desc, vertical_desc

    def analyze_pitch_sequence(
        self,
        pitch_sequence: list
    ) -> dict:
        """
        íˆ¬êµ¬ ì‹œí€€ìŠ¤ ë¶„ì„

        Args:
            pitch_sequence: List of pitch dicts
                [
                    {
                        'release_speed': 95.0,
                        'plate_x': -0.5,
                        'plate_z': 2.8,
                        'batter_stand': 'L',
                        'pitch_type': 'FF'
                    },
                    ...
                ]

        Returns:
            analysis: {
                'evs': [EV values],
                'deltas': [EV deltas],
                'avg_delta': float,
                'max_delta': float,
                'min_delta': float
            }
        """
        evs = []
        deltas = []

        # Reset last_ev
        self.last_ev = None

        for pitch in pitch_sequence:
            ev = self.calculate_ev(
                release_speed=pitch['release_speed'],
                plate_x=pitch['plate_x'],
                plate_z=pitch['plate_z'],
                batter_stand=pitch['batter_stand']
            )
            evs.append(ev)

            delta = self.get_velocity_delta(current_ev=ev)
            if delta is not None:
                deltas.append(delta)

        analysis = {
            'evs': evs,
            'deltas': deltas,
            'avg_delta': np.mean(deltas) if deltas else 0.0,
            'max_delta': np.max(deltas) if deltas else 0.0,
            'min_delta': np.min(deltas) if deltas else 0.0,
            'total_pitches': len(pitch_sequence)
        }

        return analysis


def main():
    """ì‚¬ìš© ì˜ˆì‹œ"""
    print("=" * 80)
    print("ğŸ¯ EffectiveVelocityCalculator ì˜ˆì œ")
    print("=" * 80 + "\n")

    # 1. Calculator ì´ˆê¸°í™”
    calculator = EffectiveVelocityCalculator()
    print()

    # 2. ë‹¨ì¼ íˆ¬êµ¬ ë¶„ì„
    print("ğŸ“Š ë‹¨ì¼ íˆ¬êµ¬ ë¶„ì„")
    print("-" * 80)

    # Example: ì¢Œíƒ€ì ìƒëŒ€ ëª¸ìª½ ë†’ì€ ê³µ (Inner High)
    pitch1_speed = 95.0  # mph
    pitch1_x = -0.5  # ft (ì¢Œíƒ€ì ëª¸ìª½)
    pitch1_z = 2.8  # ft (ë†’ì€ ê³µ)
    batter = 'L'

    ev1 = calculator.calculate_ev(pitch1_speed, pitch1_x, pitch1_z, batter)
    loc1 = calculator.get_location_descriptor(pitch1_x, pitch1_z, batter)

    print(f"Pitch 1: {pitch1_speed} mph @ ({pitch1_x:.2f}, {pitch1_z:.2f}) vs {batter}H")
    print(f"  Location: {loc1[0]} / {loc1[1]}")
    print(f"  Effective Velocity: {ev1:.2f} mph")
    print(f"  Impact: {ev1 - pitch1_speed:+.2f} mph\n")

    # Example: ì¢Œíƒ€ì ìƒëŒ€ ë°”ê¹¥ìª½ ë‚®ì€ ê³µ (Outer Low)
    pitch2_speed = 87.0  # mph (changeup)
    pitch2_x = 0.5  # ft (ì¢Œíƒ€ì ë°”ê¹¥ìª½)
    pitch2_z = 2.0  # ft (ë‚®ì€ ê³µ)

    ev2 = calculator.calculate_ev(pitch2_speed, pitch2_x, pitch2_z, batter)
    loc2 = calculator.get_location_descriptor(pitch2_x, pitch2_z, batter)
    delta = calculator.get_velocity_delta(current_ev=ev2)

    print(f"Pitch 2: {pitch2_speed} mph @ ({pitch2_x:.2f}, {pitch2_z:.2f}) vs {batter}H")
    print(f"  Location: {loc2[0]} / {loc2[1]}")
    print(f"  Effective Velocity: {ev2:.2f} mph")
    print(f"  Impact: {ev2 - pitch2_speed:+.2f} mph")
    if delta is not None:
        print(f"  Delta from Pitch 1: {delta:.2f} mph\n")
    else:
        print(f"  Delta from Pitch 1: N/A (first pitch)\n")

    # 3. íˆ¬êµ¬ ì‹œí€€ìŠ¤ ë¶„ì„
    print("=" * 80)
    print("ğŸ”„ íˆ¬êµ¬ ì‹œí€€ìŠ¤ ë¶„ì„")
    print("=" * 80 + "\n")

    sequence = [
        {
            'release_speed': 95.0,
            'plate_x': -0.5,
            'plate_z': 2.8,
            'batter_stand': 'L',
            'pitch_type': 'FF'
        },
        {
            'release_speed': 92.0,
            'plate_x': 0.0,
            'plate_z': 2.5,
            'batter_stand': 'L',
            'pitch_type': 'SI'
        },
        {
            'release_speed': 87.0,
            'plate_x': 0.5,
            'plate_z': 2.0,
            'batter_stand': 'L',
            'pitch_type': 'CH'
        },
        {
            'release_speed': 84.0,
            'plate_x': 0.3,
            'plate_z': 1.8,
            'batter_stand': 'L',
            'pitch_type': 'SL'
        }
    ]

    analysis = calculator.analyze_pitch_sequence(sequence)

    print("Pitch Sequence Results:")
    for i, (pitch, ev) in enumerate(zip(sequence, analysis['evs']), 1):
        loc = calculator.get_location_descriptor(
            pitch['plate_x'], pitch['plate_z'], pitch['batter_stand']
        )
        print(f"  {i}. {pitch['pitch_type']}: "
              f"{pitch['release_speed']:.1f} mph -> {ev:.2f} mph EV "
              f"({loc[0]}/{loc[1]})")

    print(f"\nSequence Statistics:")
    print(f"  Average EV Delta: {analysis['avg_delta']:.2f} mph")
    print(f"  Maximum EV Delta: {analysis['max_delta']:.2f} mph")
    print(f"  Minimum EV Delta: {analysis['min_delta']:.2f} mph")

    # 4. ìš°íƒ€ì ë¹„êµ
    print("\n" + "=" * 80)
    print("ğŸ”„ ì¢Œíƒ€ì vs ìš°íƒ€ì ë¹„êµ")
    print("=" * 80 + "\n")

    # ë™ì¼í•œ íˆ¬êµ¬, ë‹¤ë¥¸ íƒ€ì
    pitch_speed = 95.0
    pitch_x = -0.5  # ìŒìˆ˜ = ì¢Œíƒ€ìì„ ë°©í–¥
    pitch_z = 2.5

    # ì¢Œíƒ€ì
    calculator_reset = EffectiveVelocityCalculator()
    ev_left = calculator_reset.calculate_ev(pitch_speed, pitch_x, pitch_z, 'L')
    loc_left = calculator_reset.get_location_descriptor(pitch_x, pitch_z, 'L')

    # ìš°íƒ€ì
    ev_right = calculator_reset.calculate_ev(pitch_speed, pitch_x, pitch_z, 'R')
    loc_right = calculator_reset.get_location_descriptor(pitch_x, pitch_z, 'R')

    print(f"Same Pitch @ ({pitch_x:.2f}, {pitch_z:.2f}), {pitch_speed} mph")
    print(f"  vs LHH: {ev_left:.2f} mph ({loc_left[0]}) - {ev_left - pitch_speed:+.2f} mph")
    print(f"  vs RHH: {ev_right:.2f} mph ({loc_right[0]}) - {ev_right - pitch_speed:+.2f} mph")
    print(f"  Difference: {abs(ev_left - ev_right):.2f} mph")

    print("\n" + "=" * 80)
    print("âœ… ì™„ë£Œ")
    print("=" * 80)


if __name__ == "__main__":
    main()
